ğŸ§  First: This Is NOT a File

Your brain is thinking:

â€œReader reached end â†’ where does next line come from?â€

But this stream is a live network socket, not stored data.

ğŸŒŠ Whatâ€™s Actually Happening Underneath
4
ğŸ”Œ Layer 1 â€” Wikimedia Server

Wikimedia has a server constantly generating events:

User edits page â†’ Event created â†’ Sent to SSE stream


That server pushes text over an open HTTP connection like this:

data: {json1}\n
\n
data: {json2}\n
\n
data: {json3}\n

ğŸŒ Layer 2 â€” TCP Socket (The Hidden Pipe)

When this line runs:

Response response = client.newCall(request).execute();


OkHttp:

Opens a TCP socket

Performs HTTP handshake

Keeps connection OPEN

Server keeps writing bytes into that socket

Think of a pipe between your app and Wikimedia.

ğŸ“¥ Layer 3 â€” response.body().byteStream()
InputStream input = response.body().byteStream();


This InputStream is connected directly to that socket.

So:

Server writes bytes â†’ Socket receives â†’ InputStream buffers

ğŸ“– Layer 4 â€” BufferedReader
BufferedReader reader = new BufferedReader(new InputStreamReader(input));


BufferedReader:

Keeps an internal memory buffer

Waits until it sees a newline \n

Returns ONE line at a time

ğŸ” Now Your Exact Question

After one data: line is readâ€¦
Where does the NEXT line come from?

The answer:

reader.readLine() BLOCKS (pauses) until:

More bytes arrive from Wikimedia

Those bytes reach the socket

InputStream reads them

BufferedReader detects a newline

It returns the next line

ğŸ¯ Timeline Example
Time T1 â†’ readLine() called
Time T2 â†’ No data yet â†’ thread WAITING
Time T3 â†’ Someone edits Wikipedia
Time T4 â†’ Server pushes "data: {...}\n"
Time T5 â†’ Socket receives bytes
Time T6 â†’ BufferedReader gets full line
Time T7 â†’ readLine() RETURNS line


So your loop is basically:

while(true) {
    WAIT for internet data
    process event
}

ğŸ’¡ KEY CONCEPT: Blocking I/O

This line:

line = reader.readLine();


is blocking I/O.

It literally means:

â€œPause this thread until the internet gives me a full line.â€

No polling.
No loop inside.
The OS + OkHttp handle waiting.

ğŸ§µ Thread State While Waiting

When no event is happening:

Your thread = SLEEPING
CPU usage = almost zero
Connection = still open


So this is efficient.

ğŸ”¥ Super Simple Analogy

Imagine:

ğŸ“ Youâ€™re on a phone call
ğŸ‘‚ You say nothing and just listen
The other person speaks whenever they want

You donâ€™t hang up.
You donâ€™t ask repeatedly.
You just wait.

readLine() = â€œlisten for next sentenceâ€

ğŸ§© Final Mental Model
Wikimedia Server writes text
        â†“
Internet
        â†“
TCP Socket
        â†“
OkHttp InputStream
        â†“
BufferedReader buffer
        â†“
readLine() returns next line

ğŸš€ One-Sentence Summary

The next line doesnâ€™t â€œexistâ€ yet â€” readLine() sleeps until Wikimedia pushes more data into the open socket, and then returns it.